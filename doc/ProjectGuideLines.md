## Правила написания кода в RR и PP

1) Взаимодействие Lightning компонента с Apex контроллером строится следующим образом:
    - контроллер содержит все необходимые врапперы для отправки данных в компонент (не нужно враппер-классы, которые относятся исключительно к логике контроллера пихать в сервисные классы! Создаем враппер-классы внутри сервисных только в том случае если они используются в нескольких местах и это логически обоснованно)
    - саму логику делегируем сервисным и контекстным классам 
    - инициализируем враппер с даннымим, заполняем его данными от сервисных классов и отправляем в компонент.
    - оборачиваем всю логику в try - catch и используем AuraHelper.throwException(e) для передачи ошибки в компонент
    - APEX контроллер для Lightning компонентов называем с окончанием Remote, для Visualforce - с окончанием Controller


2) Логику на backend разбиваем по принципу:
    - все общие методы группируем по сервисным классам, которые должны содержать набор процедур, объединенных по какому то принципу, обычно по типу объекта. Пример: все методы по работе с Participant Enrollment находятся в ParticipantEnrollmentService. Сервисные классы которые планируется подменять Mock объектами нужно оформлять как объект у которого есть статический метод getInstance() этот метод должен возвращать инстанс объекта сервиса, созданный через ClassFactory. Это позволит в дальнейшем при написании тестов подменить сервисный объект его мок-заглушкой и для этого нужно будет использовать функционал ClassFactory. Использовать мок-тестирование рекомендуется только в исключительных случаях (нет возможности создать объект в базе данных, нужно протестировать только небольшой кусок функциональности, нужно протестировать взаимодействие с внешними системами и т.п.)
    - логику которая относится к контексту помещаем в сервисные контекстные классы. Эти классы должны быть синглетонами (создание inctance объекта лучше делать через ClassFactory) и иметь функционал относящийся к соответствующему контексту. На данный момент контекстные методы находятся в сервисных классах и часто взывают проблемы когда нужно использовать эти сервисные классы вне контекста. В будущем нужно эти методы вынести в контекстные классы которые уже в свою очередь должны  использовать функционал сервисных классов но в рамках текущего контекста. В будущем планируется завести контекстные классы ParticipantContext, ContactContext, UserContext. 
    - методы сервисов желательно сразу делать пригодными для обработки массива входных данных а не единичных данных. Это важно, так как эти методы могут использоваться в триггерах и в бачах.   

    **Пример:** 
        
    ***Нужно написать метод который возвращает всех делегатов для текущего контакта партисипанта.***
        
    **Решение:**
        
    1) Нужно создать метод который для списка Id контактов возвращает мапу содержащую список делегатов для каждого контакта (Map<Id, List<Id>>) и поместить этот метод в сервисный класс ParticipantDelegateService.
    2) Также нужно добавить соотвествующий метод getDelegates в контекстный класс ParticipantContext (пока он в перспективе), который будет в свою очередь вызывать метод сервисного класса и передавать в него список из одного элемента и брать из результирующей мапы нужное значение.




## Правила написания тестов

1) Для тестирования кода в приоритете интеграционные тесты а не unit тесты. Т. е. тесты которые проверяют всю цепочку взаимосвязанных элементов логики а не одно звено изолированно. Если мы говорим про тестирование контроллеров то соответственно нужно протестировать в первую очередь все методы контроллера а не все методы сервиса которые он использует. Такой подход позволяет писать и поддерживать тесты эффективно. Один интеграционный тест способен проверить намного больший функционал по сравнению с одним юнит теcтом. При этом при изменении логики не придется тратить большое количество времени на изменения теста.

2) Для написания интеграционного теста необходимо использовать класс TestData, который содержит логику для создания тестовых данных. 

3) Для экономии времени выполнения нужно базовую загрузку данных поместить в метод с аннотацией @TestSetup и вызвать в этом методе: TestData.loadData(). А в каждом тесте уже можно инициализировать набор данных с помощью testDataInstance = new TestData(). Объект testDataInstance будет хранить необходимый набор данных. Далее необходимо выполнить тестируемую логику под нужным пользователем и выполнить проверки. Чем больше тестов будет в одном классе тем быстрее они будут выполняться, так как для каждого теста не нужно будет вновь загружать один набор данных. Таким образом нужно стремиться интеграционные группировать в классы, один интеграционный тест в одном классе - неэффективный подход.

Пример интеграционного теста:

```Java
@IsTest
private class Test_IntegrationTestDemo {
    
    @TestSetup
    static void init(){
        TestData.loadTestData();
    }
    
    @IsTest
    static void test1() {
        Test.startTest();
        TestData testDataInstance = new TestData();
        System.runAs(testDataInstance.participantUser){
            //run and test some logic under participant
        }
    
        Test.stopTest();
    }
}
```



## Правила написания unit-тестов c использованием mock  сервисов
1) Мок тестирование используем только в исключительных случаях

2) Мок тестирование подразумевает тестирование части функциональности а работу остального функционала имитируют подстановкой мок-объектов вместо реальных объектов. Для такого подхода необходимо чтобы логика сервисного класса была реализована в обычных методах объекта, а не в статических методах класса, так как подстановка работает для объектов (экземпляров класса) а не для классов. 

3) Сервисный класс должен инстанциироваться через ClassFactory. Удобно поместить в сервисный класс сразу же метод getInstance() который будет уже содержать обращение к ClassFactory получение экземпляра класса. Если реализуется синглетон то экземпляр класса так же первоначально инстанциируется через ClassFactory и сохраняется в статической приватной переменной instance. При последующем вызове уже возвращается экземпляр класса сохраненный в этой переменной

4) Структура теста представляет из себя сначала подстановку необходимых мок-объектов вместо реальных сервисов, затем запуск того функционала который нужно протестировать. Важно понимать что смешивать мок тестирование с интеграционным не имеет никакого смысла. К примеру если в тесте сначала заполняются какие-то данные в базе данных и потом еще к этому подставляются мок-объекты вместо каких-то сервисных классов то тест в таком случае превращается в подгонку результатов  и не выполняет своей функции, в дальнейшем такой тест очень сложно поддерживать и помимо этого уходит одно из преимуществ мок тестирования - возможности быстро проверить локализованный функционал, так как заполнение БД данными всерано отнимет достаточно времени. Если используется мок тестирование то нужно тогда отсекать весь функционал который не нужно тестировать с помощью моков.



Пример юнит теста с использованием mock сервисов:

```Java
@IsTest
private class Test_UnitMockDemo {
    
    @IsTest
    static void testBehavior() {
        //setup mocks for ServiceClass1 and ServiceClass2
        ClassFactory.clearStubTypesByClassNamesMap();
        ClassFactory.putStubTypeByClassName(SomeServiceClass1.class, StubBuilder.newInstance(SomeServiceClass1.class)
                .when('someMethodName1')
                .then('... put here value for method 1 (type Object)')
                .when('someMethodName2')
                .then('... put here value for method 2 (type Object)')
                .build()
        );
        ClassFactory.putStubTypeByClassName(SomeServiceClass2.class, StubBuilder.newInstance(SomeServiceClass2.class)
                .when('someMethodName1')
                .then('... put here value for method 1 (type Object)')
                .when('someMethodName2')
                .then('... put here value for method 2 (type Object)')
                .build()
        );
        Test.startTest();
        //test logic here...
        Test.stopTest();
    }
}
```







## Правила написания триггеров

1) В самом триггере не должно быть никакой логики. Триггер должен быть один на объект и должен называться как объект с окончанием Trigger. Прежде чем  создавать новый файл для триггера нужно убедиться что для этого объекта еще нет созданного триггера.

2) В декларации триггера должны быть указаны все возможные события (before insert, before update ...)

3) Логику для триггера нужно размещать в  хэндлер-классе наследованном от TriggerHandler. В классе хэндлера перекрываем методы только для нужных нам событий. Нужно размещать несколько хэндлеров в один общий класс, так нагляднее. Тогда класс который содержит хендлеры должен называться как триггер с добавлением в конце слова Handler. Вложенные в него хэндлеры должны отражать в названии то что они делают, один хэндлер должен быть на один вид дейтсвия или групы однородных действий. Не правильно, к примеру, совмещать в одном хэндлере логику отправки записей во внешнюю систему и логику отправки email уведомлений. В таком случае должно быть два хэндлера с соответствующими названиями и два эти хендлера должны быть перечислены в триггере. Тогда глядя в триггер на используемые хэндлеры можно будет легко понять по их названиям что в триггере выполняется. Подробная информация по написанию триггеров есть в документе TriggerFramework.md. 

4) Логика хэндлера должна вызывать сервисные классы. Возможно размещение приватных методов с дополнительной функциональностью в хэндлере

пример триггера:

```Java
trigger AlertTrigger on Alert__c (before insert, before update, before delete, after insert, after update, after delete, after undelete) {
     TriggerHandlerExecutor.execute(AlertTriggerHandler.ValidateFieldsHandler.class);
 }
```

Пример хэндлера:

```Java
public without sharing class AlertTriggerHandler {
    
    public class ValidateFieldsHandler extends TriggerHandler{
        
        public override void beforeInsert(List<SObject> newList) {
            validateFields(newList);
        }
        
        public override void beforeUpdate(List<SObject> newList, Map<Id, SObject> oldMap) {
            validateFields(newList);
        }
    }
    
    private static void validateFields(List<Alert__c> newList){
        // logic here
    }
}
```


## Работа со структурой проекта

При написании кода нужно стремится группировать логику. Если к примеру вы создаете какой-то новый функционал и он абсолютно независимый, то логично его поместить в отдельную папку с названием, отражающем его функционал, это позволит в дальнейшем лучше ориентироваться в проекте и даст возможность переиспользовать этот код в другом проекте, просто скопировав в него папку. Либо в будущем можно перенести этот модуль/фичу в отдельный проект и сделать на его основе Unlocked Package. Соответственно при проектировании логики нужно стараться ее сразу разделять на функциональные, максимально независимые части. И размещать эти части по отдельным папкам. Такой подход повышает культуру кода и общий порядок в проекте, нежели бездумное накидывание логики в первые попавшиеся классы не заботясь о том как потом с этим кодом работать, как его переиспользвать и так далее.

Пример:

Логика написания триггеров, TriggerHandlerExecutor и TriggerHandler. Поместив всю логику в одном месте (папка trigger-framework) можно легко в будущем перенести ее в другой проект, помимо этого проект становится более упорядоченным.





## Структура проекта

#### На данный момент проект содержит две основные папки с кодом:
- **unpackaged** - в этой папке содержатся все файлы которые в дальнейшем не должны попасть в деплоймент и нужны для инициализации Scratch орги)
- **force-app** (основная папка проекта в которой содержится весь код и метаданные которые должны попасть в дистрибутив проекта для деплоя) Состоит из двух основных папок: 
    1) lib - в ней содержатся все универсальные фичи, неспецифичные для проекта, которые можно переисползловать в других проекта
    2) main - в ней содержится все что связано с проектом

#### Структура папки force-app/lib:
- ***integration-framework*** - ядро для выполнения вызовов во внешнюю систему с логированием
- ***mock-framework*** - ядро для выпонения мок тестирования
- ***parameters-provider***
- ***scheduled-batch*** - ядро для выполняние бачей по расписанию с панелью управления
- ***search-framework*** - ядро для выполнения полного или постраничного поиска с использованием фильтров
- ***setting-store*** - ядро для храниения любых объектов/сеттингов в базе данных в контексте пользователя или организации
- ***translation-framework*** - ядро для перевода данных (таблица Translation, триггеры, сервисный класс и т.п.)
- ***trigger-framework*** - фреймворк для написания триггерной логики
- ***ui-common*** - в данной папке нужно размещать все универсальные компоненты которые можно многократно использовать
- ***utilities*** - содержит утилитные вспомогательные классы по работе с БД, типами данных, костюмными объектами и так далее

#### Структура папки force-app/main:

- ***backend-ctp-setup*** - содержит компоненты для настройки CTP на бэке (закладки на транице CTP) и все вспомогательные компоненты
- ***community-common*** - универсальные компоненты используемы в рамках community (не подходят для использования на бэке, так как имеют специфический CSS для community) 
- ***community-pages-common*** - содержат общие страницы для PP и RH
- ***community-pages-rh*** - страницы и компоненты для RH
- ***community-pages-pp*** - страницы и компоненты для PP
- ***community-template*** - в данной папке размещаем все что связано с шаблоном комунити, меню навигации, меню профиля, темы, лейауты и т.п.
- ***default*** - содержит все что подтягивается из скрэтч орги, все новые поля, объекты, лэйауты и так далее. Новые объекты созданные в скрэтч орге соответственно попадут в папку main/default/objects. Если вы работаете с какой-то изолированной фичей и хотите разместить все ее компоненты в отдельной папке то после процедуры pull нужно посмотреть в этой папке новые метаданные и переместить их в нужную папку затем сделать push. В общем в этой папке содержится "happy soup" из всего что есть в проекте и еще не упорядочено в какой то специальной папке
- ***deprecated*** - содержит все что уже не нужно и в последствии можно удалить при миграции в Unlocked packages. В текущем варианте деплоймента у нас нет возможности удалить что-то из целевой орги при деплое, по этому мы просто помечаем пока метаданные, перенося их в эту папку. Deprecated классы нужно переносить в папку deprectaed/classes и у этих классов нужно удалять все тело чтобы они не влияли на code coverage. Остальные метаданные нужно тоже деактивировать по возможности и перенести сюда. Просто удалять что либо из проекта нельзя! 
- ***integration*** - логика интеграции (все staging таблицы, триггеры для интеграции, сервисы и т.п.)
- ***messaging*** - все что связано с уведомлениями, email templates, visualforce components и т.п.
- ***scheduled-batch-implementation*** - бачи по расписанию
- ***tests*** - все тесты, тесты для функционально независимых частей должны размещаться совместно в той папке где и модуль
- ***translation*** - все что связыно с переводами для проекта
- ***trigger-implementation*** - реализация триггерной логики (опять же для функционально независимых модулей триггерная логика должна быть внутри папки модуля)

На данный момент разбиение проекта на подпапки находится еще в процессе и те папки что описаны выше не содержат все метаданные которые к ним относятся и часть из них по прежнему лежит в папке default