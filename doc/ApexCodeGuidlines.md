## Правила написания кода в RR и PP

1) Взаимодествие Lightning компонента с Apex контроллером строится следующим образом:
    - контроллер содержит все необходимые врапперы для отправки данных в компонент (не нужно враппер-классы, которые относятся исключительно к логике контроллера пихатть в сервисыне классы? Создаем врппер-классы внутри сервисных только в том случае если они исопльзуются в нескольких местах и это логически обоснованно)
    - саму логику делегируем сервисным и контекстным классам
    - инициализируем враппер с даннымим, заполняем его данными от сервиснх классов и отрпавляем компоненту
    - оборачиваем всю логику в try - catch и испльзуем AuraHelper.throwException(e) для передачи ошибки в компонент
    - APEX контроллер для Lightning компонентов называем с окончанием Remote, для Visualforce - с окончанием Controller

2) Логику на backend разбиваем по принципу:
    - все общие методы группируем по сервисным классам, которые должны сождержать набор процедур объединенных по какому то принципу, обычно по типу объекта. Пример: все методы по работе с Participant Enrollment находятся в ParticipantEnrollmentService. Методы статические. Сервисные классы которые планируется подменяться Mock классами делаем без статических методов, либо дублируем вызов в статических методов не статических.
        - логику которая относится к контексту помещаем в сервисные контекстные классы. Эти классы должны быть синглетонами и иметь функционал относящийся к соответствующему контексту. На данный момент контекстные методы находятся в сервисных классах и часто взывают проблемы когда нужно использовать эти сервисные классы вне контекста. В будущем нужно эти методы вынести в контекстные классы которые уже в свою очередь должны  использовать функционал сервисных классов но в рамках текущего контекста. В будущем планируется завести контекстные классы ParticipantContext, ContactContext, UserContext. Все они должны быть синглетонами. 
        - методы сервисов желательно сразу делать пригодными для обработки массива входных данных а не единичных данных. Это важно, так как эти методы могут испльзоваться в триггерах и в бачах.   

        **Пример:** 
        
        _Нужно написать метод который возвращает всех делегатов для текущего контакта партисипанта._
        
        **Решение:**
        
        1) Нужно создать метод который для списка Id контактов возвращает мапу содержащую список делегатов для каждого контакта (Map<Id, List<Id>>) и поместить этот метод в сервисный класс ParticipantDelegateService.
        2) Также нужно добавить соотвествующий метод getDelegates в контекстный класс ParticipantContext (пока он в перспективе), который будет в свою очередь вызывать метод сервисного класса и передавать в него список из одного элемента и брать из результирующей мапы нужное значение.

   

## Правила написания тестов

1) Для тестирования кода в приоритете интеграционные тесты а не unit тесты. Т. е. тесты которые проверяют всю цепочку взаимосвязанных элементов логики а не одно звено изолированно. Если мы говорим про тестирование контроллеров то соответственно нужно протестировать в первую очередь все методы контроллера а не все методы сервиса которые он использует. Такой подход позволяет писать и поддерживать тесты эффективно. Один интеграционный тест способен проверить намного больший функционал по сравнению с одним юнит теcтом. При этом при изменении логики не придется тратить большое количество времени на изменения теста.
2) Для написания интеграционного теста необходимо использовать класс TestData, который содержит логику для создания тестовый данных. 
3) Для экономии времени выполнения нужно базовую загрузку данных поместить в метод с аннотацией @TestSetup и вызвать в этом методе: TestData.loadData(). А в каждом тесте уже можно инициализировать набор данных с помощью testDataInstance = new TestData(). Объект testDataInstance будет хранить необходимый набор данных. Далее необходимо выполнить тестируемую логику под нужным пользователем и выполнить проверки. Чем больше тестов будет в одном классе тем быстрее они будут выполняться, так как для каждого теста не нужно будет вновь загружать один набор данных

## Правила написания триггеров



## Работа со структурой проекта

## Структура проекта