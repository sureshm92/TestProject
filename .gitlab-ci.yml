image: ajit2408/studyhub-sfdx
stages:
    - SonarCheck 
    - Validate
    - Deploy
    - RUNTEST
    
SonarCheck:
  stage: SonarCheck
  allow_failure: true
  only:
      refs: 
        - merge_requests
      variables:
        - $CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^INT|^INF/
  image:
      name: sonarsource/sonar-scanner-cli:latest
      entrypoint: [""]
  cache:
     key: "${CI_JOB_NAME}"
     paths:
       - .sonar/cache
  before_script:
     - echo "Sonar Analysis"
  script:
     - |
             ls -ll
             apk upgrade --update-cache --available && apk add openssl curl jq 
             openssl s_client -connect  sonarqube:443 | keytool -import -noprompt -alias sonarqbue_test -keystore $JAVA_HOME/lib/security/cacerts -storepass changeit
             sonar-scanner -Dsonar.branch.name=$CI_COMMIT_REF_NAME -Dsonar.exclusions=**/*.js,**/*.xml,**/*.html -Dsonar.apex.coverage.reportPath=$CI_PROJECT_DIR/results/test-result-codecoverage.json
             #sonar-scanner -Dsonar.apex.coverage.reportPath=$CI_PROJECT_DIR/tests/apex/test-result-codecoverage.json -Dsonar.branch.name=master
             cat .scannerwork/report-task.txt
             export url=$(cat .scannerwork/report-task.txt | grep ceTaskUrl | cut -c11- ) #URL where report gets stored
             echo $url
             sleep 90s #Wait time for the report
             curl -k -u "$SONAR_TOKEN":"" $url -o analysis.json
             cat analysis.json
             export status=$(cat analysis.json | jq -r '.task.status') #Status as SUCCESS, CANCELED or FAILED
             export analysisId=$(cat analysis.json | jq -r '.task.analysisId') #Get the analysis Id
             echo "URL" $url
             echo "status" $status
             echo  "analysisId" $analysisId
     - |
       if [ "$status" == "SUCCESS" ];then 
         echo -e "SONAR ANALYSIS SUCCESSFUL...ANALYSING RESULTS";
         curl -k -u "$SONAR_TOKEN":"" $SONAR_HOST_URL/api/qualitygates/project_status?analysisId=$analysisId -o result.txt; #Analysis result like critical, major and minor issues
         export result=$(cat result.txt | jq -r '.projectStatus.status');
          if [ "$result" == "ERROR" ];then
           echo -e "SONAR RESULTS FAILED";
           echo "$(cat result.txt | jq -r '.projectStatus.conditions')"; #prints the critical, major and minor violations
           exit 1 #breaks the build for violations
          else
           echo -e "SONAR RESULTS SUCCESSFUL";
           echo "$(cat result.txt | jq -r '.projectStatus.conditions')";
           exit 0 
          fi
       else 
        echo -e "\e[91mSONAR ANALYSIS FAILED\e[0m";
        exit 1 #breaks the build for failure in Step2
       fi	
  
Validate:
  stage: Validate
  #allow_failure: true
  only:
      refs: 
        - merge_requests
          #echo $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
      #variables:
        #- $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "CICDDEMO1"
  artifacts:
      untracked: true      
      when: always
      paths:
          - results
          - package/package.xml
  before_script: 
      - |
         # “get_mr_parent” function allows to get parent commit of merge request
         # only valid for pipelines started in scope of MR.
         set -x 
         function get_mr_parent() {
         
           git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME --depth=2147483647
           git fetch origin $CI_COMMIT_REF_NAME --depth=2147483647
         
           get_parent_command="git merge-base origin/$CI_COMMIT_REF_NAME origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME"
                   
           PARENT="$(eval $get_parent_command || true)"
         
           if [[ -z $PARENT ]]; then
              git fetch --unshallow --update-head-ok origin '+refs/heads/*:refs/heads/*'  # global var GIT_DEPTH: "2147483647" is about the same
             PARENT="$(eval $get_parent_command)"
           fi  
           
           echo "[DEBUG] Parent commit for the MR #$CI_MERGE_REQUEST_IID is $PARENT"
           # git merge --squash FETCH_HEAD
         }
         get_mr_parent
         export PARENT
         echo 'y' | sfdx plugins:install sfdx-git-delta
         sfdx sgd:source:delta --to "HEAD" --from $PARENT --output "."
         echo "--- package.xml generated with added and modified metadata ---"
         cat package/package.xml
         #echo "---- Deploying added and modified metadata ----"
      #- sfdx force:source:deploy -x package/package.xml      
  script:
      - mkdir results  
      - echo "${!CI_MERGE_REQUEST_TARGET_BRANCH_NAME}" > sfdx-auth-url
      - "echo 'y' | sfdx force:auth:sfdxurl:store -f sfdx-auth-url -a $CI_MERGE_REQUEST_TARGET_BRANCH_NAME -d"
      - sfdx force:source:deploy -x package/package.xml -u $CI_MERGE_REQUEST_TARGET_BRANCH_NAME -c -w 60 
      #- sfdx force:apex:test:run -y -u INT --resultformat junit --codecoverage --testlevel RunLocalTests --outputdir results
      - echo "Validate success!"
      

Deploy:
    #when: manual
    stage: Deploy
    only:
      variables:
      - $CI_COMMIT_REF_NAME =~ /^INT|^INF/
    before_script: 
      - |
         set -x
         echo 'y' | sfdx plugins:install sfdx-git-delta
         sfdx sgd:source:delta --to "HEAD" --from "HEAD^" --output "."
         echo "--- package.xml generated with added and modified metadata ---"
         cat package/package.xml
         #echo "---- Deploying added and modified metadata ----"
      #- sfdx force:source:deploy -x package/package.xml      
    script:
      - ls -ll
      - echo $CI_COMMIT_REF_NAME
      - echo "${!CI_COMMIT_REF_NAME}" > sfdx-auth-url
      - "echo 'y' | sfdx force:auth:sfdxurl:store -f sfdx-auth-url -a $CI_COMMIT_REF_NAME -d"
      - sfdx force:source:deploy -x package/package.xml -u $CI_COMMIT_REF_NAME -w 60
      - echo "Deploy success!"

RUNTEST:
  only:
    - INFY
  except:
    - merge_requests
  
  stage: RUNTEST
  script: 
  - . ./scripts/ci/run-tests.sh INFY

